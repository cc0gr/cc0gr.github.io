<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式之观察者模式</title>
    <url>/2019/10/17/observer/</url>
    <content><![CDATA[<h1 id="设计模式之观察者模式-c"><a href="#设计模式之观察者模式-c" class="headerlink" title="设计模式之观察者模式-c++"></a>设计模式之观察者模式-c++</h1><p>定义了对象间的一对多的依赖关系，让多个观察者对象同时监听某一个主题对象（被观察者）。当主题对象的状态发生更改时，会通知所有观察者，让它们能够自动更新。也称之为发布(Publish)-订阅(Subscribe)模式。<br><img src="/o7key/o7key.github.io/2019/10/17/observer/observer.jpg" alt="UML"></p><p>Subject（抽象主题）：跟踪所有观察者，并提供添加和删除观察者的接口。<br>Observer（抽象观察者）：为所有的具体观察者定义一个接口，在得到主题的通知时进行自我更新。<br>ConcreteSubject（具体主题）：将有关状态存入各 ConcreteObserver 对象。当具体主题的状态发生任何更改时，通知所有观察者。<br>ConcreteObserver（具体观察者）：实现 Observer 所要求的更新接口，以便使本身的状态与主题的状态相协调。</p><a id="more"></a>

<p>代码实现：</p>
<ol>
<li><p><strong>创建抽象主题类</strong>：</p>
<p>提供关于注册、注销、通知观察者的接口</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// subject.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SUBJECT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUBJECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Observer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象主题类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>; <span class="comment">//注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Detach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>; <span class="comment">//注销观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//通知观察者</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><p><strong>创建具体主题</strong></p>
<p>抽象主题的具体实现，用于管理所有的观察者。</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//concrete_subject.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONCERTE_SUBJECT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCERTE_SUBJECT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"subject.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"observer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象具体主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> :</span> <span class="keyword">public</span> Subject</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteSubject()</span><br><span class="line">    {</span><br><span class="line">        m_Value = <span class="number">12</span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_Value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(Observer*observer)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_observers.push_back(observer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Detach</span><span class="params">(Observer*observer)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_observers.remove(observer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">list</span>&lt;Observer*&gt;::iterator it = m_observers.begin();</span><br><span class="line">        <span class="keyword">while</span>(it != m_observers.end())</span><br><span class="line">        {</span><br><span class="line">            (*it)-&gt;Updata(m_Value);</span><br><span class="line">            ++it;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;Observer *&gt; m_observers; <span class="comment">//观察者列表</span></span><br><span class="line">    <span class="keyword">int</span> m_Value;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><p><strong>创建抽象观察者</strong></p>
<p>提供一个 Update() 接口,用于更新数据</p>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//observer.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Updata</span><span class="params">(<span class="keyword">int</span> value)</span> </span>= <span class="number">0</span>;<span class="comment">//更新值</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li><strong>创建具体观察者</strong></li>
</ol>
<p>抽象观察者的具体实现，当接收到通知后便会更新对应的值</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//concrete_observer.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONCRETE_OBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCRETE_OBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"observer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteObserver(<span class="built_in">string</span> name){m_name = name;}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Updata</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_name： "</span>&lt;&lt;<span class="string">" --- value: "</span>&lt;&lt;value&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>测试mian.cpp实现：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"concrete_observer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"concrete_subject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DELETE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE(obj) {<span class="meta-keyword">if</span>(obj){delete(obj);(obj)=NULL;}}</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建主题、观察者</span></span><br><span class="line">    ConcreteSubject *subjectobj = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">    ConcreteObserver *observer1 = <span class="keyword">new</span> ConcreteObserver(<span class="string">"json"</span>);</span><br><span class="line">    ConcreteObserver *observer2 = <span class="keyword">new</span> ConcreteObserver(<span class="string">"mark"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册观察者</span></span><br><span class="line">    subjectobj-&gt;Attach(observer1);</span><br><span class="line">    subjectobj-&gt;Attach(observer2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值、更新</span></span><br><span class="line">    subjectobj-&gt;SetValue(<span class="number">13</span>);</span><br><span class="line">    subjectobj-&gt;Notify();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注销观察者</span></span><br><span class="line">    subjectobj-&gt;Detach(observer1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次更改状态,并通知观察者</span></span><br><span class="line">    subjectobj-&gt;SetValue(<span class="number">15</span>);</span><br><span class="line">    subjectobj-&gt;Notify();</span><br><span class="line"></span><br><span class="line">    DELETE(observer1);</span><br><span class="line">    DELETE(observer2);</span><br><span class="line">    DELETE(subjectobj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2019/10/16/Singleton/</url>
    <content><![CDATA[<h1 id="设计模式之单例模式-c"><a href="#设计模式之单例模式-c" class="headerlink" title="设计模式之单例模式-c++"></a>设计模式之单例模式-c++</h1><p>功能：</p><p>​        在整个软件生命周期，保证一个类只有一个实例，并提供一个访问它的全局访问点，关键是构造函数私有化，不允许多次构造</p><p>单例模式分两种：</p><ol>
<li><p>饿汉模式：不管程序有没有用到这个实例，都会进行构造处理，是一种空间换时间的做法。</p>
</li>
<li><p>懒汉模式：只有程序想要使用这个实例的时候才会去创建，不需要创建实例程序就“懒得”去创建实例。</p>
</li>
</ol><a id="more"></a>



<p>饿汉模式代码实现：</p>
   <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestoryInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != m_instance)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">delete</span> m_instance;</span><br><span class="line">            m_instance = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton()</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"创建了一个单例对象"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_instance; <span class="comment">//指向单例对象的指针</span></span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;); <span class="comment">//拷贝构造私有化</span></span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton);</span><br><span class="line">    </span><br><span class="line">    ~Singleton()</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//这里析构函数私有化的原因：使用这个实例对象在程序运行的整个过程中要使其都存在，不能让实例对象自己主动的调用析构函数释放对象</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"销毁了一个单例对象"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::GetInstance()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Singleton * singletonObj = Singleton::GetInstance();</span><br><span class="line">    singletonObj-&gt;DestoryInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>   由此可知创建唯一 实例的步骤：</p>
<ol>
<li>将默认的构造函数私有化，这样就不能利用默认构造函数创建出普通的对象</li>
<li>在类中创建出唯一的对象，new一个对象，并且将这个对象设置为static</li>
<li>将拷贝构造私有化，这样就不能通过拷贝构造创建出对象</li>
<li>将这个唯一实例对象的指针私有化</li>
<li>供一个public的静态方法来获取这个类唯一的一个实例化对象<br>懒汉模式实现：</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>{</span><br><span class="line">         <span class="keyword">if</span>(m_Instance == <span class="literal">NULL</span>)</span><br><span class="line">         {</span><br><span class="line">             m_Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">return</span> m_Instance;</span><br><span class="line">     }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestoryInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (m_Instance != <span class="literal">NULL</span> )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">delete</span> m_Instance;</span><br><span class="line">            m_Instance = <span class="literal">NULL</span> ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> m_test;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    Singleton(){ m_test = <span class="number">10</span>; };</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_Instance;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp;m_Instance){};</span><br><span class="line">    <span class="keyword">int</span> m_test;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Singleton * Singleton::m_single = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">    Singleton *singletonObj = Singleton ::GetInstance();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;singletonObj-&gt;GetTest()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Singleton::DestoryInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个实现方法其实还存在着很多问题，比如没有考虑到多线程的问题，如果在多线程的情况下，就有可能创建了多个Singleton实例对象，会出现线程安全隐患，为了解决这个问题，我们可以引入双检锁-DCL机制。</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestoryInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (m_Instance != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">delete</span> m_Instance;</span><br><span class="line">            m_Instance = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton(){<span class="built_in">cout</span>&lt;&lt;<span class="string">"创建了一个单例对象"</span>&lt;&lt;<span class="built_in">endl</span>;}; <span class="comment">//构造函数私有化</span></span><br><span class="line"></span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton);</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_Instance; <span class="comment">//指向单例对象的指针</span></span><br><span class="line">    ~Singleton(){<span class="built_in">cout</span>&lt;&lt;<span class="string">"销毁了一个单例对象"</span>&lt;&lt;<span class="built_in">endl</span>;};</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> mutex m_mutex; <span class="comment">//锁</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Singleton*Singleton::m_Instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::GetInstance()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( m_Instance == <span class="literal">NULL</span> )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);<span class="comment">//自解锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            m_Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_Instance;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Singleton *singletonObj = Singleton::GetInstance();</span><br><span class="line">    </span><br><span class="line">    singletonObj-&gt;DestoryInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，就可以保证线程安全了，但是，会带来较小的性能影响,因为加锁会影响到内核的一些切换。</p>
<p>资源释放：</p>
<p>有内存申请，就要有对应的释放，可以采用下述两种方式：</p>
<ul>
<li>主动释放（手动调用接口来释放资源）</li>
<li>自动释放（由程序自己释放）</li>
</ul>
<p>要手动释放资源，添加一个 static 接口，编写需要释放资源的代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestoryInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>{</span><br><span class="line">       <span class="keyword">if</span> (m_Instance != <span class="literal">NULL</span>)</span><br><span class="line">       {</span><br><span class="line">           <span class="keyword">delete</span> m_Instance;</span><br><span class="line">           m_Instance = <span class="literal">NULL</span>;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>然后在需要释放的时候，手动调用该接口,方式虽然简单，但很多时候容易忘记调用 DestoryInstance(),那么我们可以创建一个清理的类去进行清理。</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton(){<span class="built_in">cout</span>&lt;&lt;<span class="string">"创建了一个单例对象"</span>&lt;&lt;<span class="built_in">endl</span>;}; <span class="comment">//构造函数私有化</span></span><br><span class="line"></span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton);</span><br><span class="line">    <span class="keyword">static</span> Singleton *m_Instance; <span class="comment">//指向单例对象的指针</span></span><br><span class="line">    ~Singleton(){<span class="built_in">cout</span>&lt;&lt;<span class="string">"销毁了一个单例对象"</span>&lt;&lt;<span class="built_in">endl</span>;};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> mutex m_mutex; <span class="comment">//锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理工人类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Garbo</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Garbo()</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//在程序开始前执行的代码</span></span><br><span class="line">        }</span><br><span class="line">        ~Garbo()</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (m_Instance != <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"here destroy  the m_Instance...... "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">delete</span> m_Instance;</span><br><span class="line">                m_Instance = <span class="literal">NULL</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> Garbo gc;<span class="comment">//用于释放单例</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//一定要声明Garbo</span></span><br><span class="line">Singleton::Garbo Singleton::Garbo::gc;</span><br><span class="line"></span><br><span class="line">Singleton*Singleton::m_Instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::GetInstance()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( m_Instance == <span class="literal">NULL</span> )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex);<span class="comment">//自解锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_Instance == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            m_Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_Instance;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Singleton *singletonObj = Singleton::GetInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之万能密码原理</title>
    <url>/2019/10/14/06-sec/</url>
    <content><![CDATA[<p>万能密码通常是指开发人员在开发过程中使用超级管理员进行开发，开发完成后没有过滤掉这些常用的超级管理员；另一种是存在SQL漏洞管理员账号。</p><ol>
<li><p>万能密码：用户名 admin、密码admin，用户名admin、密码123456</p>
</li>
<li><p>万能密码：用户名 ‘or’=’or’、密码 ‘or’=’or’<br>&nbsp;&nbsp;原理解释：假设用户登录对应的语句为：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, pwd <span class="keyword">from</span> login <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">''</span> <span class="keyword">and</span> pwd=<span class="string">''</span>;</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol><a id="more"></a>

<p>如果用户名输入正确则直接登录，否则提示用户名或密码错误，使用万能密码后的SQL语句如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, pwd <span class="keyword">from</span> login <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">''</span><span class="keyword">or</span><span class="string">'='</span><span class="keyword">or</span><span class="string">''</span> <span class="keyword">and</span> pwd=<span class="string">''</span><span class="keyword">or</span><span class="string">'='</span><span class="keyword">or</span><span class="string">''</span>;'</span><br></pre></td></tr></tbody></table></figure>

<p>核心代码，两个单引号匹配，即name=’’，然后or连接，单引号等于单引号(‘=’)这是恒成立的，紧接着or连接两个单引号(‘’)，同理密码pwd。这样or连接的(‘=’)是恒成立的，故返回结果为真，导致直接登录。</p>
<ol start="3">
<li><p>万能密码：用户名 ‘or’’=’、密码’or’’=’<br>&nbsp;&nbsp;原理解释：此时对应的SQL语句如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">, pwd from login where name=''or''='' and pwd=''or''='';'</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>万能密码：用户名’or’=’–、密码’or’=’–<br>原理解释：此时对应的SQL语句如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, pwd <span class="keyword">from</span> login <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">''</span><span class="keyword">or</span><span class="string">'='</span><span class="comment">--' and pwd=''or'='--';</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<p>通过搜索引擎输入 inurl:login.asp等搜索技术找到一些列网站后台登录界面后，反复尝试这些万能密码进行登录。防范措施也比较简单：</p>
<ol>
<li>开发人员开发完成后，过滤掉admin等常用账号或修改密码；</li>
<li>当用户第一次登录的时候，对简单的密码进行修改提示，防止暴力破解；</li>
<li>用户名或密码屏蔽掉单引号(‘)、等号(=)、注释(–)等特殊字符；</li>
<li>对尝试SQL注入的IP地址进行报警提示或日志记录。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>webSec</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之05信息收集篇</title>
    <url>/2019/10/14/05-sec/</url>
    <content><![CDATA[<p>在开展渗透测试时，需要采用各种可能的方法收集将要攻击的客户组织信息，那么主要收集什么？</p><ul>
<li>Whois信息<ul>
<li>注册人名字、邮箱等</li>
</ul>
</li>
<li>IP信息（服务器的IP）<ul>
<li>判断是否为CDN节点，查询同IP网站，端口扫描</li>
</ul>
</li>
<li>目录信息<ul>
<li>判断WEB应用，获取网站后台目录，获取其他</li>
</ul>
</li>
<li>服务器信息<ul>
<li>判断服务，例如：IIS、Apache、Nginx</li>
</ul>
</li>
<li>脚本信息<ul>
<li>ASP、PHP、aspx、（asp.net）</li>
</ul>
</li>
<li>框架信息<ul>
<li>ThinkPHP、Struts等</li>
</ul>
</li>
<li>应用信息<ul>
<li>应用，dedecms、phpcms等</li>
</ul>
</li>
<li>子域名信息<ul>
<li>xxx.xx.com , xxx.xxx.xx.com</li>
</ul>
</li>
</ul><a id="more"></a>

<h3 id="WHOIS"><a href="#WHOIS" class="headerlink" title="WHOIS"></a>WHOIS</h3><p>查询工具：<a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com</a></p>
<p> </p>
<h3 id="IP信息"><a href="#IP信息" class="headerlink" title="IP信息"></a>IP信息</h3><p>我们可以ping某个 URL：</p>
<p>windows下win+r会弹出运行框输入<font color="#FF3E96">cmd</font>（即command）可以进入命令行:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;ping www.xxx.com</span><br></pre></td></tr></tbody></table></figure>

<p>​    ping完之后判断是否为CDN的ip,可以使用<a href="http://ping.chinaz.com/" target="_blank" rel="noopener">多地ping工具</a>来进行判断。一般来说，使用了CDN的网站在不同地点的Ping的结果是不一样的。</p>
<p><strong>查找源站<code>IP</code></strong></p>
<ol>
<li>查询子域：许多情况下只有主站使用了CDN，二级站点并没有，所以我们就可以直接查询分站的 IP。分站的搜索方法见下文。</li>
<li>国内部分CDN服务只针对国内有效，对国外的访问几乎不使用CDN。所以我们可以通过国外冷门DNS 查询域名。</li>
</ol>
<h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><p>nslookup用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题。</p>
<p>使用方式：</p>
<ul>
<li>直接查询</li>
</ul>
<p>nslookup domain [dns-server]<br> 如果没有指定dns服务器，就采用系统默认的dns服务器。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">nslookup xxx.com</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>b. 查询其他记录</li>
</ul>
<p>nslookup -qt = <font color="#FF1493">type</font> domain [dns-server] </p>
<p><font color="#FF1493">type</font> :</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">A 	--&gt;地址记录</span><br><span class="line">AAAA    --&gt;地址记录</span><br><span class="line">AFSDB Andrew   --&gt;文件系统数据库服务器记录</span><br><span class="line">ATMA 	--&gt;ATM地址记录</span><br><span class="line">CNAME   --&gt;别名记录</span><br><span class="line">HINHO   --&gt;硬件配置记录，包括CPU、操作系统信息 </span><br><span class="line">ISDN    --&gt;域名对应的ISDN号码</span><br><span class="line">MB      --&gt;存放指定邮箱的服务器</span><br><span class="line">MG      --&gt;邮件组记录</span><br><span class="line">MINFO   --&gt;邮件组和邮箱的信息记录</span><br><span class="line">MR      --&gt;改名的邮箱记录</span><br><span class="line">MX      --&gt;邮件服务器记录</span><br><span class="line">NS     --&gt; 名字服务器记录</span><br><span class="line">PTR    -&gt;反向记录</span><br><span class="line">RP     --&gt;负责人记录</span><br><span class="line">RT     --&gt;路由穿透记录</span><br><span class="line">SRV    --&gt;TCP服务器信息记录</span><br><span class="line">TXT    --&gt;域名对应的文本信息</span><br><span class="line">X25    --&gt;域名对应的X.25地址记录</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>查询更具体的信息</li>
</ul>
<p>nslookup -d [其他参数] domain [dns-server]<br>只要在查询的时候，加上-d参数，即可查询域名的缓存</p>
<ol start="3">
<li>历史解析记录：CDN的IP地址之前所用的IP就是真实IP。</li>
</ol>
<p>历史解析记录使用工具：<a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report?url=</a></p>
<ol start="4">
<li>查询邮件：很多服务器自带邮件发送功能，可以利用它来获取真实IP。让站点主动发送邮件，然后右键查询源代码，就能获得真实IP。</li>
</ol>
<p>工具检测旁站工具：<a href="http://tool.chinaz.com/same/。" target="_blank" rel="noopener">http://tool.chinaz.com/same/。</a></p>
<ol start="5">
<li>端口扫描可以使用Nmap工具,下载：<a href="https://nmap.org/" target="_blank" rel="noopener">https://nmap.org/</a></li>
</ol>
<h3 id="目录信息"><a href="#目录信息" class="headerlink" title="目录信息"></a>目录信息</h3><h4 id="1-主动式扫描：爬虫、暴力破解"><a href="#1-主动式扫描：爬虫、暴力破解" class="headerlink" title="1. 主动式扫描：爬虫、暴力破解"></a>1. 主动式扫描：爬虫、暴力破解</h4><ul>
<li><p>AVWS：(Acunetix Web Vulnerability Scanner)是一个网站及服务器漏洞扫描软件，根据站点的链接进行扫描</p>
</li>
<li><p><a href="http://www.jb51.net/softs/43405.html" target="_blank" rel="noopener">御剑</a>：根据固定的字典进行主动式扫描</p>
</li>
</ul>
<h4 id="2-被动式扫描：Burp-Spider"><a href="#2-被动式扫描：Burp-Spider" class="headerlink" title="2. 被动式扫描：Burp Spider"></a>2. 被动式扫描：Burp Spider</h4><h4 id="3-Google-Hacking-谷歌黑语法"><a href="#3-Google-Hacking-谷歌黑语法" class="headerlink" title="3. Google Hacking(谷歌黑语法)"></a>3. Google Hacking(谷歌黑语法)</h4><ul>
<li><p>site：搜索与指定网站有联系的 URL</p>
</li>
<li><p>intitle：搜索网页标题中包含有特定字符的网页</p>
</li>
<li><p>inurl：搜索包含有特定字符的 URL</p>
</li>
<li><p>Info:    搜索 一些基本信息</p>
</li>
<li><p>intext：搜索网页正文内容中的指定字符</p>
</li>
<li><p>filetype：搜索指定类型的文件</p>
<p>补充：</p>
<p>a&gt; 双引号</p>
<p>把搜索词放在双引号中，代表<strong>完全匹配搜索</strong>也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。百度和Google 都支持这个指令。例如搜索： “WEB安全”</p>
<p>b&gt; 减号</p>
<p>减号<strong>代表搜索不包含减号后面的词的页面。</strong>使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google 和百度都支持这个指令。<br>例如：搜索 -引擎<br>返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果</p>
<p>c&gt;  星号</p>
<p>星号<em>是常用的通配符，也可以用在搜索中。百度不支持</em>号搜索指令</p>
<p>d&gt;  一些示例</p>
</li>
</ul>
<ol>
<li><p>查询存在<code>SQL</code>注入漏洞的网站：</p>
<p><font color="red">inurl:asp?id=</font></p>
</li>
<li><p>搜索开放远程桌面的WEB连接的服务器</p>
<p><font color="red">allinurl:tsweb/default.htmsite:com</font></p>
</li>
<li><p>搜索网站的公共FTP用户</p>
<p>site:XXX.com   intext:ftp://:</p>
</li>
<li><p>搜索指定网站的Google快照</p>
<p><font color="red">Cache:xxx.com</font></p>
</li>
<li><p>收集Discuz论坛主机</p>
<p>Intext：Poweredby  Discuz</p>
</li>
</ol>
<h4 id="4-robots-txt"><a href="#4-robots-txt" class="headerlink" title="4. robots.txt"></a>4. robots.txt</h4><p>打开浏览器，在输入框输入<a href="http://www.xxx.com/robots.txt" target="_blank" rel="noopener">www.xxx.com/robots.txt</a>, 重点要看<font color="#EE2C2C">Disallow</font>的部分。</p>
<h4 id="5-联网设备搜索"><a href="#5-联网设备搜索" class="headerlink" title="5. 联网设备搜索"></a>5. 联网设备搜索</h4><ul>
<li><p>钟馗之眼<a href="http://www.zoomeye.com" target="_blank" rel="noopener">www.zoomeye.com</a></p>
</li>
<li><p>傻蛋<a href="http://www.oshadan.com。" target="_blank" rel="noopener">www.oshadan.com。</a></p>
</li>
</ul>
<p>联网设备搜索引擎可以检索到许多搜索引擎不收录的页面，通常是后台等页面。</p>
<p>构造检索关键词时：</p>
<ul>
<li><p>系统/后台类，可以搜索“xxx系统/平台/管理”。</p>
</li>
<li><p>企业类，可以搜索“xxx企业/公司/平台”。</p>
</li>
</ul>
<h3 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h3><p>主要查看返回的数据包的<font color="#EE2C2C">Server</font>的内容，获取Server信息,通过Sever字段可以判断使用的服务器类型。</p>
<h3 id="脚本信息"><a href="#脚本信息" class="headerlink" title="脚本信息"></a>脚本信息</h3><ol>
<li>查看返回的数据包中的<font color="#EE2C2C">X-Powered-By</font>的值。</li>
<li>查看返回的数据包中的<font color="#EE2C2C">cookie</font>中的信息</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">PHPSESSID</span><br><span class="line">ASPSESSID</span><br></pre></td></tr></tbody></table></figure>

<p>如：出现了PHPSESSID，说明站点可能使用了PHP编写</p>
<h3 id="框架信息"><a href="#框架信息" class="headerlink" title="框架信息"></a>框架信息</h3><p>通过报错信息或是URL结构获取网站使用的框架信息。如ThinkPHP，Struts等。</p>
<h3 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h3><p>目录特征、文件特征、指纹扫描工具、网站特征等。</p>
<p>比如存在wp-login.php就可能是WordPress。</p>
<h3 id="子域名信息"><a href="#子域名信息" class="headerlink" title="子域名信息"></a>子域名信息</h3><ul>
<li>搜索引擎：site:*.xxx.com</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>webSec</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之04基础篇</title>
    <url>/2019/10/14/04-sec/</url>
    <content><![CDATA[<h2 id="网络攻防环境"><a href="#网络攻防环境" class="headerlink" title="网络攻防环境"></a>网络攻防环境</h2><p>&nbsp;&nbsp;一个基本的网络攻防实验环境包括：<font color="#FF4040">靶机</font>、<font color="#FF4040">攻击机</font>、<font color="#FF4040">入侵检测分析系统</font>、<font color="#FF4040">网络连接</font>四部分组成</p><p><font color="#FF3030">靶机</font>：包含系统和应用程序漏洞，并且作为攻击目标的主机。</p><p><font color="#FF3030">攻击机：用于发起网络攻击的主机,可以使用kali,一个渗透测试人员专用平台</font></p><p><font color="#FF3030">攻击检测、分析与防御平台</font>：</p><p>&nbsp;&nbsp;<font color="#FF3030">IDS</font>：Intrusion Detection Systems，<font color="#FF3030">入侵检测系统</font>，是一种主动保护自己免受攻击的一种网络安全技术,专门检测有没有非法的入侵数据流。<br>IDS在交换式网络中的位置一般可以选择为尽可能靠近攻击源、尽可能靠近受保护资源的地方,一般部署位置在internet接入路由器之后的第一台交换机。</p><a id="more"></a>




<p>&nbsp;&nbsp;<font color="#FF3030">IPS</font>：Intrusion Prevention System，<font color="#FF3030">入侵防御系统</font>,可以检测到入侵之后的下一步就是要对入侵进行防御。<br>一般部署位置在办公网与外部网络的连接部位（入口/出口)，即网关，也可以是重要服务器集群前端，办公网内部接入层。</p>
<p><font color="#FF3030">网络连接</font>：通过网络将靶机、攻击机和具备检测分析防御功能的网关进行连接,即交换机、网关、网线等</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>webSec</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之03基础篇</title>
    <url>/2019/10/13/03-sec/</url>
    <content><![CDATA[<h2 id="渗透测试术语"><a href="#渗透测试术语" class="headerlink" title="渗透测试术语"></a>渗透测试术语</h2><p><font color="#EE4000">SQL</font><br>SQL（Struct Querry Language）<font color="#EE799F">结构化查询语言</font>,是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名</p><p><font color="#EE4000">XSS</font><br>CSS（Cross  Site Script）<font color="#EE799F">跨站脚本攻击</font>，为了和HTML中的CSS（层叠样式）进行区分，在信息安全领域内，我们习惯将跨站脚本攻击称为“XSS”</p><a id="more"></a>

<p><font color="#EE4000">CSRF</font><br>CSRF（Cross-site request forgery）<font color="#EE799F">跨站请求伪造</font>，也是一种漏洞的类型。</p>
<p><font color="#EE4000">SSRF</font><br>SSRF(Server-Side Request Forgery)<font color="#EE799F">服务器请求伪造</font>，是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。</p>
<p><font color="#EE4000">WAF</font><br>WAF（WebApplicationFirewall）<font color="#EE799F">WEB应用防护系统</font>，也称之为网站应用级入侵防御系统。</p>
<p><font color="#EE4000">Exploit</font><br>Exploit，<font color="#EE799F">漏洞利用代码</font>。时常我们会看到不少的CVE漏洞被公布出来，有些CVE漏洞就会附加一些Exploit的代码程序，只要你将代码以正确的形式针对合适的目标测试那么就会显示出最后的效果。</p>
<p><font color="EE4000">Payload</font><br>Payload即<font color="EE799F">有效载荷</font>，被隐藏并且秘密发送的信息。</p>
<p><font color="EE4000">Webshell</font><br> WebShell，顾名思义，“web”的含义是显然需要服务器开放WEB服务，“shell”的含义是取得对服务器某种程度上操作权限。黑客在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问这些asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载文件，查看数据库，执行任意程序命令等）。由于webshell其大多是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。</p>
<p> <font color="EE4000">木马</font><br> 木马是病毒的一种,分为<font color="EE799F">软件木马</font>和<font color="EE799F">脚本木马</font>，软件木马就是一个恶意控制的软件，脚本木马就是脚本语言编写的木马程序。</p>
<p> <font color="EE4000">poc</font><br> Prood of concept,即<font color="EE799F">漏洞验证程序</font></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>webSec</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之02基础篇</title>
    <url>/2019/10/13/02-sec/</url>
    <content><![CDATA[<h2 id="信息系统安全的定义"><a href="#信息系统安全的定义" class="headerlink" title="信息系统安全的定义"></a>信息系统安全的定义</h2><p>a&gt;<font color="#FF4040"> 机密性(Confidentiality)</font>:对信息或资源的隐藏，信息不被非授权人员所获取，本质上就是不被”非授权人员”读取，也就是<font color="#FF4040">控制”r”权限</font></p><p>b&gt;<font color="#FF4040"> 完整性 （Integrity)</font>：对数据或资源的可信赖程度，通常用于表述防止不当或未经授权的修改，也就是<font color="#FF4040">控制”w”权限</font>,主要是为了阻止未经授权的改写数据企图         </p><a id="more"></a>

<p>c&gt;<font color="#FF4040">可用性 (Availability)</font>：使用所期望的信息或资源的能力,例如DOS攻击就是通过破坏系统的可用性来达到攻击的目的</p>
<p>d&gt;<font color="#FF4040">可追溯性(Traceability)</font>：系统须保证对数据的访问和系统能力的使用的个人行为的可追溯性，并且提供审计这些行为的方法,主要涉及三个要素：标识、鉴别、审计</p>
<p><strong>安全评估过程的构成</strong><br>一个安全评估的过程，可以简单的分为4个阶段：<strong>资产等级划分</strong>、<strong>威胁分析</strong>、<strong>风险分析</strong>、<strong>确认解决方案</strong>。</p>
<h3 id="资产等级划分"><a href="#资产等级划分" class="headerlink" title="资产等级划分"></a>资产等级划分</h3><p><strong>资产等级划分</strong>：是进行所有工作的基础，这项工作能够帮助我们明确目标是什么，要保护什么。<br><font color="red">互联网安全的核心问题是数据安全的问题</font>。</p>
<p>&nbsp;&nbsp;资产等级划分的过程需要和各个业务部门的负责人一一沟通，<strong>了解公司最重要的资产是什么</strong>，他们最<strong>看重的数据是什么</strong>。通过访谈的形式，安全部门才能熟悉、了解公司的业务，公司所拥有的数据，以及不同数据的重要程度，为后续的安全评估过程指明方向。</p>
<p> &amp;nsp;&nbsp;在完成资产等级划分之后，需要<font color="#EE9572">划分信任域</font>和<font color="#EE9572">信任边界</font>。通常我们用一种最简单的划分方式就是从网络逻辑上来划分。比如最重要的数据放在数据库里面。那么把数据库的服务器圈起来；WEB应用可以从数据库中读取数据并对外提供服务，那再把WEB服务器圈起来，最外面的是不可信任的</p>
<h4 id="威胁分析"><a href="#威胁分析" class="headerlink" title="威胁分析"></a>威胁分析</h4><p>&nbsp;&nbsp; 在安全领域里，我们把可能造成危害的来源称为“<font color="#EEA2AD">威胁（Threat）</font>”，而把可能会出现的所示称为<font color="#EEA2AD">风险（Risk）</font>。风险一定是和损失联系在一起的。</p>
<p>&nbsp;&nbsp;所谓的威胁分析就是<font color="#EEA2AD">将所有的威胁都找出来</font>。一般采用头脑风暴的方法。当然也有一些比较科学的方法，比如使用一个模型帮助我们去思考去分析。</p>
<p> 在做威胁分析时，要尽可能的不遗漏威胁，头脑风暴的过程可以确定攻击面（AttackSurface）。</p>
<h3 id="风险分析"><a href="#风险分析" class="headerlink" title="风险分析"></a>风险分析</h3><p><strong>风险由以下因素组成</strong>：<br><font color="red"> Risk=Probability*Damage Potential</font></p>
<p><strong>影响风险高低的因素除了造成损失的大小之外还有考虑到发生的可能性。</strong></p>
<p>&nbsp;&nbsp;现今也有不少的风险分析模型比如微软提出的DREAD模型。但是在任何时候都应该记住——模型是死的，人是活的，再好的模型也是需要人来使用的，在确定攻击方面，以及判断风险高低时，都需要一定的经验，这也是安全工程师的价值所在。</p>
<h3 id="确认解决方案"><a href="#确认解决方案" class="headerlink" title="确认解决方案"></a>确认解决方案</h3><p>&nbsp;&nbsp;安全评估的产出物，就是安全解决方案。解决方案一定要有针对性，这种针对性是由资产等级划分、威胁分析、风险分析等阶段的结果给出的。</p>
<p>&nbsp;&nbsp;设计安全方案不难，难的是如何设计一个好的解决方案。设计一个好的解决方案，是真正考验安全工程师水平的时候。</p>
<p>&nbsp;&nbsp;作为安全工程师，要想的就是如何通过简单而有效的方案，解决遇到的安全问题。安全方案能够有效的抵抗威胁，但同时不能过多干涉正常的业务流程，在性能上也不能拖后腿。</p>
<p><font color="#EEA2AD">好的安全方案对用户应该是透明的，尽可能地不要改变用户的使用习惯。</font></p>
<p>&nbsp;&nbsp;好的安全产品或模块除了要兼顾用户体验外，还要易于持续改进。一个好的安全模块，同时也应该是一个优秀的程序，从设计上也需要做到高聚合，地耦合、易于扩展。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>webSec</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之01基础篇</title>
    <url>/2019/10/13/01-sec/</url>
    <content><![CDATA[<h2 id="渗透测试的定义："><a href="#渗透测试的定义：" class="headerlink" title="渗透测试的定义："></a>渗透测试的定义：</h2><p>渗透测试是受信任的第三方通过模拟黑客可能使用的攻击手段对目标系统的安全性作出风险评估并针对目标系统所存在的风险给出安全修复建议的一个测试过程。</p><p>注意：开展渗透测试前，一定要获取目标主机的官方有效授权，注意规避法律风险</p><p>意义：<br>通过渗透测试，可以使系统管理人员、系统开发人员及时了解到系统潜在的“安全危机”（薄弱点），并及时进行修复，加强系统的安全性，避免不必要的损失。</p><a id="more"></a>


<h2 id="渗透测试的分类："><a href="#渗透测试的分类：" class="headerlink" title="渗透测试的分类："></a>渗透测试的分类：</h2><p><strong>（1）黑盒测试</strong><br>定义：渗透测试人员除了知道被测试的目标之外，其余于目标相关的信息一无所知<br>特点：这种类型的渗透测试属于外部渗透测试。在前期需要对目标进行大量的信息收集，耗时较长。但是这种类型的渗透测试更有利于挖掘出系统潜在的漏洞、以及脆弱环节、薄弱点等。</p>
<p><strong>（2）白盒测试</strong><br>定义：渗透测试人员可以通过正常渠道向被测试单位取得各种资料，包括网络拓扑结构图、员工资料甚至网站程序的代码片段，也可以和单位其他员工进行面对面沟通。<br>特点：这种类型的渗透测试在前期已经对目标系统有了一个初步的了解。这类测试的地点可以分为“从组织内部”与“从组织外部”两种大环境。在这种测试下可以充分发挥<strong>“社会工程学的力量”</strong>，对企业内部雇员的越权操作进行测试。</p>
<p><strong>（3）灰盒测试</strong><br>定义：灰盒测试介于白盒测试与黑盒测试之间。<br>特点：属于较为隐秘的测试。在测试当中，被测试单位只有少数人知晓测试的存在，因此能够较好的检验单位中的信息安全事件监控、响应等是否到位。</p>
<h2 id="渗透测试按照测试目标可以分为四类："><a href="#渗透测试按照测试目标可以分为四类：" class="headerlink" title="渗透测试按照测试目标可以分为四类："></a>渗透测试按照测试目标可以分为四类：</h2><p><strong>（1）操作系统渗透</strong><br>Windows、Linux、Solaris、AIX、SCO等</p>
<p><strong>（2）数据库系统渗透</strong><br>MySQL 、Oracle、MSSQL、sybase、informix</p>
<p><strong>（3）应用系统渗透</strong><br>由ASP、JSP、PHP等组成的web应用（包括移动应用产品）</p>
<p><strong>（4）网络设备渗透</strong><br>防火墙、入侵检测系统等</p>
<h2 id="渗透测试流程："><a href="#渗透测试流程：" class="headerlink" title="渗透测试流程："></a>渗透测试流程：</h2><p><strong>（1）渗透测试目标以及界限的明确</strong><br>在进行渗透测试之前，需要与客户就渗透测试的目标、渗透测试的范围、渗透测试方式（黑盒、白盒、灰盒以及是否涉及社会工程学）进行商讨，达成一致协议，这一点至关重要。</p>
<p><strong>（2）信息收集</strong><br>在（1）的基础之上，收集与将要进行渗透测试的目标相关的信息，在此过程中可以使用WEB扫描工具以及第三方信息收集工具、搜素引擎（Google）等。<br><font color="red">A： 基础信息获取</font><br>DNS域名信息<br>注册人信息（注册人姓名，电话、邮箱等）<br>网站或程序开发所涉及到的语言(php、jsp、ASP、Ajax、Html、xml等)<br>网站使用的服务器，数据库等信息</p>
<p><font color="red"> B：WEB扫描信息获取</font><br>开发端口与服务识别<br>服务器操作系统类型<br>目标网络结构…等等</p>
<p><strong>（3）威胁建模</strong><br>根据（2）中收集到的信息，对测试目标进行威胁建模，查找与渗透测试目标所开启的服务、开放的端口、使用的服务器、域名、编程逻辑、编程语言等等信息中存在的可利用漏洞信息，并且制定渗透测试方案。</p>
<p><strong>（4）前期渗透测试</strong><br>根据（3）中制定的渗透测试方案开始渗透测试<strong>（注意前期商议的渗透测试界线范围）</strong></p>
<p><strong>（5）后渗透测试</strong><br>后渗透测试主要是在前期渗透测试的基础上扩大影响范围、提高权限、建立维持访问、清理痕迹等。后渗透测试在整个渗透测试中相当重要。</p>
<p><strong>（6）渗透测试报告书写</strong><br>在这个过程中，需要将系统中所存在的漏洞、漏洞的证明、系统潜在的安全威胁、针对安全威胁给出的修复建议等给出详细的说明。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>webSec</tag>
      </tags>
  </entry>
</search>
